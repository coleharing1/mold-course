---
description: "Performance optimization patterns for Next.js applications"
globs: ["app/**/*.{tsx,jsx,ts,js}", "components/**/*.{tsx,jsx}", "lib/**/*.ts"]
tags: ["performance", "optimization", "nextjs"]
priority: "medium"
version: 1.0.0
context_limit: 200
---
# Performance Optimization Rules

## Component Performance
- Use React.memo for expensive pure components
- Implement useMemo for complex calculations
- Apply useCallback for stable function references
- Lazy load heavy components with dynamic imports
- Virtual scroll lists over 50 items

## Next.js Optimizations
- Server Components by default (no "use client" unless needed)
- Use next/image for ALL images
- Implement static generation where possible
- Code split at route boundaries automatically
- Prefetch critical routes with next/link

## Bundle Size Management
- Tree-shake unused imports
- Dynamic import large libraries
- Monitor bundle with @next/bundle-analyzer
- Keep individual chunks under 250KB
- Use production builds for testing

## Data Fetching
- Implement React Query or SWR for caching
- Debounce search inputs (minimum 300ms)
- Paginate large datasets (max 50 items)
- Use optimistic updates for better UX
- Stream large responses when possible

## Asset Optimization
- Images: WebP format, <100KB target
- Fonts: Variable fonts, subset characters
- Icons: SVG sprites or icon fonts
- Videos: Lazy load with intersection observer
- Critical CSS: Inline above-fold styles

## Metrics Targets
- First Contentful Paint: <1.5s
- Time to Interactive: <3.5s
- Cumulative Layout Shift: <0.1
- Largest Contentful Paint: <2.5s
- Total Blocking Time: <300ms